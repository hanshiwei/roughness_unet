"""
    Updated on 2025/03/05
    (1) The structured grid points on top of the volume surface will extracted.
    (2) Three steps to simulate the three stress states are included in the input file.
    (3) A node set is created and the stress values at the nodes will be extracted by using key word ELEMENT_NODAL.

    Updated on 2025/01/24
    (1) The code has been updated to process multiple '*.odb' automatically.

    Updated on 2025/01/22
    (1) Is it possible to add the odbAccess path to VS Code like other library? (NOT very necessary)

    Updated on 2025/01/20   
    (1) The model in the odb is a square plate with rough surface generated by a script named "surface_by_spline.ipynb".
    (2) The 'inp' file for this 'odb' is also formulated in the script named "surface_by_spline.ipynb".
    (3) Strain component E11 in the coating membrane is extracted from the 'odb' file.
    (4) The elements in the coat is unstructured triangular elements. 
        The values at nodes of the structured membrane will be post-processed in "surface_by_spline.ipynb".
    (5) Meanwhile, the E11 value should be normalized by the average nominal E11 strain.

    Programed on 2025/01/10

    calling this script in cmd window or in TERMINAL as:
    abaqus viewer nogui=PythonScriptName.py

"""

from odbAccess import *
import numpy as np
import math
import sys
import os
import time
import datetime
import csv
# os.write(1, b'system version is [%s].\n' % (sys.version))

"""
    The following code is used to extract the stress values at the surface grid points of the volume
    with a square hole.
"""
nom_stress = 1.0
id_job_start = 0
id_job_end = 1
abqinp_dir = "C:\\Abaqus_Works\\roughness_simulation\\cylinder"
output_dir = "C:\\Abaqus_Works\\roughness_simulation\\cylinder" 

"""
    The following code is used to extract the stress values at the surface grid points of the volume
    WITHOUT a square hole.
"""
# # e_nom = 0.005
# nom_stress = 100.0
# # full_length_um = 1276
# full_length_um = 638
# # full_length_um = 318
# # full_length_um = 636

# half_crop_grids = 0

# sub_times = 1

# id_job_start = 10000
# id_job_end = 10001

# step_name = 'Tensile_X'

# abqinp_dir = "C:\\Abaqus_Works\\roughness_simulation\\abaqus_inp_files"
# output_dir = "C:\\Abaqus_Works\\roughness_simulation\\output_free_mesh" 

# os.write(1, b'Confirm the nominal stress: [%f] MPa.\n' % (nom_stress))
# os.write(1, b'Confirm the half length of plate: [%f] um.\n' % (full_length_um))
# os.write(1, b'Number of grid cropped from edge: [%d].\n' % (half_crop_grids))
# os.write(1, b'Subtimes of the element meshing: [%d].\n' % (sub_times))

for job_id in range(id_job_start, id_job_end, 1):
    #111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
    # open ODB file
    os.write(1, b'>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n')
    # job_name = "abq_surface_L{:03d}um_C{:d}_S{:d}_ID{:05d}".format(full_length_um, half_crop_grids, sub_times, job_id)  # 
    
    # output the stress in the model of a square plate with a square hole in the center
    # job_name = "abaqus_cylinder_flat"

    os.write(1, b'ABAQUS ODB [%s] is under processing.\n' % (job_name))

    odb_name = job_name + ".odb"    
    odb_path = os.path.join(abqinp_dir, odb_name)
    os.write(1, b'ABAQUS ODB path is [%s]\n' % (odb_path))
    odb = openOdb(path=odb_path, readOnly=True)

    name_inst_volume = 'VOLUME-1'

    if name_inst_volume not in odb.rootAssembly.instances:
        os.write(1, b'instance [%s] does not exist.\n' % (name_inst_volume))
        odb.close()
        sys.exit(1)
    
    # Get the instance
    inst_volume = odb.rootAssembly.instances[name_inst_volume]

    # os.write(1, b'type: [%s] .\n' % (type(inst_volume.nodeSets)))
    # os.write(1, b'keys: [%s] .\n' % (inst_volume.nodeSets.keys()))

    # Specify the node set name
    name_nset_vol_surf_grid = 'F_VOL_SURF_STRUCT'
    if name_nset_vol_surf_grid not in inst_volume.nodeSets:
        os.write(1, b'node set [%s] does not exist in instance [%s].\n' % (name_nset_vol_surf_grid, name_inst_volume))
        odb.close()
        sys.exit(1)

    # Get the node set
    node_set_vol_surf_grid = inst_volume.nodeSets[name_nset_vol_surf_grid]

    # os.write(1, b'members: [%s] .\n' % (node_set_vol_surf_grid.__members__))
    # os.write(1, b'node set name: [%s] .\n' % (node_set_vol_surf_grid.name))

    # Retrieve the nodes in the node set
    nodes_on_surf_grid = node_set_vol_surf_grid.nodes

    sum_steps = len(odb.steps.keys())
    os.write(1, b'Sum of steps: [%d] .\n' % (sum_steps))
    os.write(1, b'Sum of nodes on surface: [%d] .\n' % (len(nodes_on_surf_grid)))

    # Create a dictionary with node labels as keys and coordinates and field values
    node_field_dict = {node.label: np.zeros(3 + 6 * sum_steps) for node in nodes_on_surf_grid}
    # Create a dictionary with node labels as keys and float values
    node_times_dict = {node.label: np.zeros(sum_steps, dtype=int) for node in nodes_on_surf_grid}

    # Fill the first three elements of the value item with the node coordinates
    for node in nodes_on_surf_grid:
        node_field_dict[node.label][:3] = node.coordinates[:]

    # Print the coordinates of the nodes in the node set
    # for node in nodes_on_surf_grid:
    #     os.write(1, b'Node label: %s at %f. \n' %(node.label, node.coordinates[0]))

    # cycle through the steps to retrive the stress values in global coordiante system
    index_step = 0
    for step_name in odb.steps.keys():
        #22222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222
        # extract the strain field
        # step_name = step_name.upper()  # There is only one step in this job
        os.write(1, b'step [%s] will be processed.\n' % (step_name))
        if step_name not in odb.steps:
            os.write(1, b'step [%s] does not exist.\n' % (step_name))
            # print(f"instance {instance_name} does not exist.")
            odb.close()
            sys.exit(2)

        frame = odb.steps[step_name].frames[-1]  # only the last frame
        field_output_S = frame.fieldOutputs['S']  # strain
        # os.write(1, b'members: [%s] .\n' % (field_output_S.locations.keys()))
        S_nodes_surf_grid = field_output_S.getSubset(region=node_set_vol_surf_grid, position=ELEMENT_NODAL).values
        # os.write(1, b'number of nodes is [%d].\n' % (len(S_nodes_surf_grid)))
        # os.write(1, b'label of nodes is [%s].\n' % (S_nodes_surf_grid[0].nodeLabel))
        # os.write(1, b'number of S is [%d].\n' % (len(S_nodes_surf_grid[0].data)))
        # extract the 'S' at surface grid points

        
        for S in S_nodes_surf_grid:
            node_label = S.nodeLabel
            # node_index = node_label - 1
            node_field_dict[node_label][3+index_step*6:3+(index_step+1)*6] += S.data[:]
            node_times_dict[node_label][index_step] += 1

            # if node_label == 21185:

            #     os.write(1, b'current label [%s] .\n' % (S.nodeLabel))
            #     os.write(1, b'S11[%f],S22[%f],S33[%f],S12[%f],S13[%f],S23[%f] .\n' 
            #             % (S.data[0],S.data[1],S.data[2],S.data[2],S.data[4],S.data[5]))
                
            #     dat += S.data[0]
            #     tim_node += 1
        # Average the values in node_field_dict by dividing by the corresponding times

        index_step += 1
        #2222222222222222222222222222222222222222222222222222222222222222222222222
    
    # average the stress at all node grid points
    for node_label, times in node_times_dict.items():
        if np.any(times == 0) or np.any(times != times[0]):
            os.write(1, b'something wrong with times at node [%d].\n' % (node_label))
            odb.close()
            sys.exit(5)

        for idx_step in range(sum_steps):
            node_field_dict[node_label][(3+idx_step*6):(3+(idx_step+1)*6)] /= float(times[idx_step])
        
        node_field_dict[node_label][ 3: ] /= nom_stress # normalize the stress by the nominal stress

    # write out the data points into a csv file
    data_csv_file = job_name + ".csv"
    data_csv_path = os.path.join(output_dir, data_csv_file)
    with open(data_csv_path, 'wb') as csvfile:
        csvwriter = csv.writer(csvfile)
        # Write the header
        header = ['Node Label', 'X', 'Y', 'Z']
        for i in range(sum_steps):
            header.extend(['S11_Step{}'.format(i+1), 'S22_Step{}'.format(i+1), 'S33_Step{}'.format(i+1), 'S12_Step{}'.format(i+1), 'S13_Step{}'.format(i+1), 'S23_Step{}'.format(i+1)])
        csvwriter.writerow(header)

        # Write the data rows
        for node_label, node_field in node_field_dict.items():
            row = [node_label] + node_field.tolist()
            csvwriter.writerow(row)
    
    os.write(1, b'csv is written to [%s]!\n'%(data_csv_path))
    os.write(1, b'Job [%s] is completed!\n'%(job_name))

    # close ODB file
    odb.close()
    os.write(1, b'<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n')
    #111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111

os.write(1, b'All jobs are finished.\n')
# sys.exit(0)

    # instance_name = 'COAT-1'
    # if instance_name not in odb.rootAssembly.instances:
    #     os.write(1, b'instance [%s] does not exist.\n' % (instance_name))
    #     # print(f"instance {instance_name} does not exist.")
    #     odb.close()
    #     sys.exit(1)
    #
    # instance_coat = odb.rootAssembly.instances[instance_name]
    #, Coordinates: {node.coordinates}
    # # coat_nodes_data:
    # #   [0,1,2] column: three dimensional coordinates
    # #   [3]     column: normalized E11 value along X direction 
    # sum_nodes_coat = len(instance_coat.nodes)
    # coat_nodes_cord = np.zeros((sum_nodes_coat, 3))

    # # get coordinates of all nodes in the COAT instance
    # for node_index in range(sum_nodes_coat):
    #     node = instance_coat.nodes[node_index]
    #     coat_nodes_cord[node_index, :] += node.coordinates[:]

    # if len(odb.steps.keys()) != 3:
    #     os.write(1, b'number of steps is not three.\n')
    #     odb.close()
    #     sys.exit(4)

    # coat_nodes_data = np.zeros((sum_nodes_coat, 9))     
    # coat_nodes_time = np.zeros((sum_nodes_coat, 1))

    # # for step in odb.steps.keys():
    # #     os.write(1, b'current step name is [%s] .\n' % (step))

    # # loop through three steps
    # index_step = 0
    # for step_name in odb.steps.keys():
    #     #22222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222
    #     # extract the strain field
    #     # step_name = step_name.upper()  # There is only one step in this job
    #     os.write(1, b'step [%s] will be processed.\n' % (step_name))
    #     if step_name not in odb.steps:
    #         os.write(1, b'step [%s] does not exist.\n' % (step_name))
    #         # print(f"instance {instance_name} does not exist.")
    #         odb.close()
    #         sys.exit(2)

    #     frame = odb.steps[step_name].frames[-1]  # only the last frame
    #     field_output_E = frame.fieldOutputs['E']  # large strain is not activated
    #     inst_coat_E = field_output_E.getSubset(region=instance_coat, position=ELEMENT_NODAL).values

    #     # extract the data
    #     """
    #     In the M3D3 element, there is only one integration point. The value at the nodes are averaged
    #         from those at integratio points of the neighboring elements.
    #     """
    #     for E in inst_coat_E:
    #         node_label = E.nodeLabel
    #         node_index = node_label - 1
    #         # os.write(1, b'length of the data is [%d].\n' % (len(E.data)))
    #         # odb.close()
    #         # sys.exit(12)
    #         coat_nodes_data[node_index, index_step*3:(index_step*3+3)] += E.data[[0,1,3]] # this is E11
    #         coat_nodes_time[node_index] += 1.0

    #     index_step += 1
    #     #2222222222222222222222222222222222222222222222222222222222222222222222222

    # if np.any(coat_nodes_time == 0):
    #     os.write(1, b'There is zero in variable coat_nodes_time.\n')
    #     odb.close()
    #     sys.exit(3)

    # # there are three steps in the odb
    # coat_nodes_time = coat_nodes_time/len(odb.steps.keys())
    # # divide the data by the times
    # coat_nodes_data = coat_nodes_data / coat_nodes_time
    # # normalize the E11 strain in the last column
    # coat_nodes_data = coat_nodes_data / e_nom

    # # node indices
    # node_index = np.arange(1, coat_nodes_data.shape[0] + 1).reshape(-1, 1)
    # coat_nodes_info = np.hstack((node_index, coat_nodes_cord, coat_nodes_data))

    # # output the E11 into a csv file
    # data_csv_file = job_name + ".csv"
    # data_csv_path = os.path.join(output_dir, data_csv_file)
    # np.savetxt(data_csv_path, coat_nodes_info, 
    #         delimiter=",", fmt=["%d", "%.9f", "%.9f", "%.9f", "%.6f", "%.6f", "%.6f", "%.6f", "%.6f", "%.6f", "%.6f", "%.6f", "%.6f"],
    #         header="NodeID,X,Y,Z,X-E11/E_Nom,X-E22/E_Nom,X-E12/E_Nom,Y-E11/E_Nom,Y-E22/E_Nom,Y-E12/E_Nom,S-E11/E_Nom,S-E22/E_Nom,S-E12/E_Nom", comments="")




